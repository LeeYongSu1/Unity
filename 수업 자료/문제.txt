1. 구조체를 정의하는 이유 :
연관있는 데이터를 묶으면 관리가 편해짐
합리적인 코드 작성가능





2. 달팽이 배열
int main()
{
	int arr[50][50];
	int len, idx, i, j;
	int s = 0, w = -1, inc = 1, val = 0;

	printf("숫자를 입력하시오: ");
	scanf_s("%d", &len);
	idx = len; //원본을 깎으면 안되기때문

	while (1)
	{
		for (i = 0; i < idx; i++) //가로 단위 그림
		{
			//2입력했을때
			//첫바퀴, 두바퀴
			val++; //0->1, 1->2
			w = w + inc; //0=-1+1, 0+1
			arr[s][w] = val; //[0][0]=1, [0][1]=2
		}
		idx = idx - 1; //

		if (val == len * len) //행열이 같아지면 빠져나간다
			break;

		for (i = 0; i < idx; i++) //세로 단위 그림
		{
			val++;;
			s = s + inc;
			arr[s][w] = val;
		}
		inc = inc * -1;
	}

	for (i = 0; i < len; i++) //달팽이 배열 출력
	{
		for (j = 0; j < len; j++)
			printf("%5d", arr[i][j]);
		printf("\n");
	}

	return 0;
}






3. 배열 90도씩
void ShowArr(int(*arr)[4]);
void RotateArr(int(*arr)[4]);

int main()
{
	int i = 0;
	int j = 0;
	int arr[4][4];
	int count = 0;

	for (i = 0; i < 4; i++)
	{
		for (j = 0; j < 4; j++)
			arr[i][j] = ++count;
	}
	ShowArr(arr);

	for (i = 0; i < 4; i++)
	{
		ShowArr(arr);
		RotateArr(arr);
	}

	return 0;
}

void ShowArr(int(*arr)[4])
{
	int i, j;
	printf("----Show Array----\n");

	for (i = 0; i < 4; i++)
	{
		for (j = 0; j < 4; j++)
			printf("%5d", arr[i][j]);
		printf("\n");
	}
	printf("\n");
}

void RotateArr(int(*arr)[4])
{
	int i, j;
	int temp[4][4];

	for (i = 0; i < 4; i++)
	{
		for (j = 0; j < 4; j++)
			temp[j][3 - i] = arr[i][j];
	}

	for (i = 0; i < 4; i++)
	{
		for (j = 0; j < 4; j++)
			arr[i][j] = temp[i][j];
	}
}






3.함수를 쓰는 이유
반복적인 프로그래밍을 피할수있다
함수를 호출하면 해당 작업을 반복해서 수행가능



4.구조체 배열 입출력
struct book
{
	char author[30];
	char title[30];
	int page;
};

int main()
{
	struct book save[3];
	puts("도서 정보 입력");
	for (int i = 0; i < 3; i++)
	{
		fputs("저자:",stdout);
		fgets(save[i].author, sizeof(save[i].author), stdin);
		fputs("제목:",stdout);
		fgets(save[i].title, sizeof(save[i].title), stdin);
		fputs("페이지 수:",stdout);
		scanf_s("%d", &save[i].page);
		while (getchar() != '\n');
		printf("\n");
	}

	for (int i = 0; i < 3; i++)
	{
		printf("book %d\n저자: %s제목: %s페이지 수: %d\n", i+1,save[i].author, save[i].title, save[i].page);
	}
}






5.Call-by-value
typedef struct
{
	int xpos;
	int ypos;
} Point;

Point AddPoint(Point pos1, Point pos2)
{
	Point pos = { pos1.xpos + pos2.xpos,
		pos1.ypos + pos2.ypos };
	return pos;
}

Point MinPoint(Point pos1, Point pos2)
{
	Point pos = { pos1.xpos - pos2.xpos,
		pos1.ypos - pos2.ypos };
	return pos;
}

int main()
{
	Point pos1 = { 5,6 }; //새롭게 할당
	Point pos2 = { 2,9 }; //구조체랑 할당하는 공간이 다르다
	Point result;

	result = AddPoint(pos1, pos2);
	printf("[%d, %d] \n", result.xpos, result.ypos);

	result = MinPoint(pos1, pos2);
	printf("[%d, %d] \n", result.xpos, result.ypos);

	return 0;
}










6.Call-by-refrence 주소의 전달은 포인터 사용
typedef struct
{
	char name[20];    // 학생 이름
	char stdnum[20];  // 학생 고유번호
	char school[20];  // 학교 이름
	char major[20];   // 선택 전공
	int year;         // 학년
} Student;

void ShowStudentInfo(Student* sptr)
{
	printf("학생 이름: %s \n", sptr->name);
	printf("학생 고유번호: %s \n", sptr->stdnum);
	printf("학교 이름: %s \n", sptr->school);
	printf("선택 전공: %s \n", sptr->major);
	printf("학년: %d \n", sptr->year);
}

int main()
{
	Student arr[2];

	for (int i = 0; i < 2; i++)
	{
		printf("이름: "); fgets(arr[i].name, sizeof(arr[i].name), stdin);
		printf("번호: "); fgets(arr[i].stdnum, sizeof(arr[i].stdnum), stdin);
		printf("학교: "); fgets(arr[i].school, sizeof(arr[i].school), stdin);
		printf("전공: "); fgets(arr[i].major, sizeof(arr[i].major), stdin);
		printf("학년: "); scanf_s("%d", &arr[i].year);
		while (getchar() != '\n');
	}

	printf("\n");

	for (int i = 0; i < 2; i++)
	{
		ShowStudentInfo(&arr[i]);
	}

	return 0;
}







7.구조체 입출력 동적할당
void ClearLineFromReadBuffer();

//매크로
#define LEN 30

typedef struct
{
	char author[LEN];
	char title[LEN];
	int page;
} book;

int main(void)
{
	book* list[3];

	printf("도서 정보 입력\n");
	for (int i = 0; i < 3; i++) //데이터 입력
	{
		book* pBook = (book*)malloc(sizeof(book) * 1);

		printf("저자 : ");
		fgets(pBook->author, LEN, stdin);

		printf("제목 : ");
		fgets(pBook->title, LEN, stdin);

		printf("페이지 수 : ");
		scanf_s("%d", &(pBook->page));

		ClearLineFromReadBuffer();

		list[i] = pBook;
	}

	printf("\n도서 정보 출력\n");
	for (int i = 0; i < 3; i++) //데이터 출력
	{
		printf("book %d \n", i + 1);
		printf("저자 : %s", list[i]->author);
		printf("제목 : %s", list[i]->title);
		printf("페이지 수 : %d \n", list[i]->page);
	}

	for (int i = 0; i < 3; i++)
	{
		free(list[i]);
	}
	return 0;
}

void ClearLineFromReadBuffer(void)
{
	while (getchar() != '\n');
}